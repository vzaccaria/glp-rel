// Generated by LiveScript 1.2.0
(function(){
  var _, winston, gulp, gif, cache, remember, concat, path, multipipe, Notification, plumber, through, fork, map, combined, passthrough, duplexer, tap, filter, notifier, debug, debugFile, t, snake, x, conditionalStream, moduleName, dispOk, dispKo, dispMsg, disp, pdisp, pdeb, _module;
  _ = require('underscore');
  _.str = require('underscore.string');
  winston = require('winston');
  gulp = require('gulp');
  gif = require('gulp-if');
  cache = require('gulp-cached');
  remember = require('gulp-remember');
  cache = require('gulp-cached');
  concat = require('gulp-concat');
  path = require('path');
  multipipe = require('multipipe');
  Notification = require('node-notifier');
  plumber = require('gulp-plumber');
  through = require('through2');
  fork = require('fork-stream');
  map = require('map-stream');
  combined = require('combined-stream');
  passthrough = require('stream').PassThrough;
  duplexer = require('duplexer2');
  tap = require('gulp-debug');
  filter = require("through2-filter");
  notifier = new Notification();
  path = require('path');
  debug = require('debug')('glp:gulp-relations');
  debugFile = function(title, object){
    var pp, bn;
    pp = path.extname(object.path);
    bn = path.basename(object.path);
    return debug(_.str.pad(title, 25) + " | -> " + _.str.pad(bn, 30) + " " + pp + " ");
  };
  t = function(title){
    return through.obj(function(object, enc, callback){
      debugFile(title, object);
      this.push(object);
      return callback();
    });
  };
  snake = duplexer;
  x = function(title, head){
    var tail;
    tail = t(title);
    head.pipe(tail);
    return snake(head, tail);
  };
  conditionalStream = function(name, condition, plugin){
    var streamSplit, streamJoin, mergedStream, toPlugin, noPlugin, a, b;
    streamSplit = through.obj();
    streamJoin = combined.create();
    mergedStream = function(s1, s2){};
    toPlugin = filter.obj(function(it){
      var cc;
      cc = condition(it);
      if (cc) {
        debugFile("send to `" + name + "`:", it);
      }
      return cc;
    });
    noPlugin = filter.obj(function(it){
      var cc;
      cc = !condition(it);
      return cc;
    });
    a = streamSplit.pipe(toPlugin).pipe(plugin);
    b = streamSplit.pipe(noPlugin);
    streamJoin.append(a);
    streamJoin.append(b);
    return duplexer(streamSplit, streamJoin);
  };
  _.mixin(_.str.exports());
  _.str.include('Underscore.string', 'string');
  moduleName = _.pad("glp-rel", 10);
  dispOk = function(){
    return winston.info("> " + moduleName + " < Ok");
  };
  dispKo = function(it){
    return winston.error("> " + moduleName + " < Ok", it.toString());
  };
  dispMsg = function(it){
    return winston.info("> " + moduleName + " <   : ", it.toString());
  };
  disp = winston.info;
  pdisp = console.log;
  pdeb = winston.warn;
  _module = function(){
    var manyToMany, manyToOne, iface;
    manyToMany = function(src, finalDir, options, isToOne){
      var signalError, wrapPlugin, filters, post, finalDest, args, i$, len$, p, pp, stream;
      isToOne == null && (isToOne = false);
      signalError = function(it){
        notifier.notify({
          message: it
        });
        debug("Error while processing " + src);
        return debug(it);
      };
      wrapPlugin = function(p){
        return p.on('error', signalError);
      };
      options == null && (options = {});
      options.compilers == null && (options.compilers = []);
      filters = options.compilers;
      post = options.post;
      finalDest = "";
      if (isToOne) {
        finalDest = path.basename(finalDir);
        finalDir = path.dirname(finalDir);
        if (options != null) {
          options.tempBuild == null && (options.tempBuild = finalDir + "/build");
        }
      }
      if (isToOne) {
        debug("Concatenating files " + src + " to " + finalDest + " in " + finalDir + " - temporary build: " + options.tempBuild);
      } else {
        debug("Processing files " + src + " to " + finalDir);
      }
      args = [gulp.src(src)];
      if (filters != null) {
        if (!_.isArray(filters)) {
          filters = [filters];
        }
        for (i$ = 0, len$ = filters.length; i$ < len$; ++i$) {
          p = filters[i$];
          args = args.concat([conditionalStream(p.name, p.pred, p.plugin())]);
        }
      }
      if (post != null) {
        if (!_.isArray(post)) {
          post = [post];
        }
        for (i$ = 0, len$ = post.length; i$ < len$; ++i$) {
          pp = post[i$];
          args = args.concat([pp()]);
        }
      }
      if (isToOne) {
        args = args.concat([gulp.dest(options.tempBuild)], [concat(finalDest)]);
      }
      args = args.concat([gulp.dest(finalDir)]);
      stream = multipipe.apply(multipipe, args);
      return stream;
    };
    manyToOne = function(src, finalDest, options){
      return manyToMany(src, finalDest, options, true);
    };
    iface = {
      manyToOne: manyToOne,
      manyToMany: manyToMany
    };
    return iface;
  };
  module.exports = _module();
}).call(this);
