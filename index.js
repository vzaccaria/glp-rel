// Generated by LiveScript 1.2.0
(function(){
  var _, winston, gulp, gif, cache, remember, concat, plumber, path, moduleName, dispOk, dispKo, dispMsg, disp, pdisp, pdeb, _module;
  _ = require('underscore');
  _.str = require('underscore.string');
  winston = require('winston');
  gulp = require('gulp');
  gif = require('gulp-if');
  cache = require('gulp-cached');
  remember = require('gulp-remember');
  cache = require('gulp-cached');
  concat = require('gulp-concat');
  plumber = require('gulp-plumber');
  path = require('path');
  _.mixin(_.str.exports());
  _.str.include('Underscore.string', 'string');
  moduleName = _.pad("glp-rel", 10);
  dispOk = function(){
    return winston.info("> " + moduleName + " < Ok");
  };
  dispKo = function(it){
    return winston.error("> " + moduleName + " < Ok", it.toString());
  };
  dispMsg = function(it){
    return winston.info("> " + moduleName + " <   : ", it.toString());
  };
  disp = winston.info;
  pdisp = console.log;
  pdeb = winston.warn;
  _module = function(){
    var manyToMany, manyToOne, iface;
    manyToMany = function(src, finalDir, options){
      var pre, predicates, i$, len$, p, ref$, pp;
      options == null && (options = {});
      options.compilers == null && (options.compilers = []);
      pre = gulp.src(src).pipe(plumber()).pipe(cache(finalDir));
      predicates = options.compilers;
      if (predicates != null && _.isArray(predicates)) {
        for (i$ = 0, len$ = predicates.length; i$ < len$; ++i$) {
          p = predicates[i$];
          pre = pre.pipe(gif(p.pred, p.plugin));
        }
      } else if (predicates != null) {
        pre = pre.pipe(gif(predicates.pred, predicates.plugin));
      }
      if (options.post != null && _.isFunction(options.post)) {
        pre = pre.pipe(options.post);
      }
      if (options.post != null && _.isArray(options.post)) {
        for (i$ = 0, len$ = (ref$ = options.post).length; i$ < len$; ++i$) {
          pp = ref$[i$];
          pre = pre.pipe(pp);
        }
      }
      pre = pre.pipe(gulp.dest(finalDir));
      return pre;
    };
    manyToOne = function(src, finalDest, options){
      var finalDir, predicates, pre, i$, len$, p, ref$, pp, results$ = [];
      options == null && (options = {});
      finalDir = path.dirname(finalDest);
      finalDest = path.basename(finalDest);
      if (options != null) {
        options.tempBuild == null && (options.tempBuild = finalDir + "/build");
      }
      options.compilers == null && (options.compilers = []);
      predicates = options.compilers;
      pre = gulp.src(src).pipe(plumber()).pipe(cache(finalDest));
      if (predicates != null && _.isArray(predicates)) {
        for (i$ = 0, len$ = predicates.length; i$ < len$; ++i$) {
          p = predicates[i$];
          pre = pre.pipe(gif(p.pred, p.plugin));
        }
      } else if (predicates != null) {
        pre = pre.pipe(gif(predicates.pred, predicates.plugin));
      }
      pre = pre.pipe(gulp.dest(options.tempBuild)).pipe(remember(finalDest)).pipe(concat(finalDest));
      if (options.post != null && _.isFunction(options.post)) {
        pre = pre.pipe(options.post);
      }
      if (options.post != null && _.isArray(options.post)) {
        for (i$ = 0, len$ = (ref$ = options.post).length; i$ < len$; ++i$) {
          pp = ref$[i$];
          results$.push(pre = pre.pipe(pp));
        }
        return results$;
      }
    };
    iface = {
      manyToOne: manyToOne,
      manyToMany: manyToMany
    };
    return iface;
  };
  module.exports = _module();
}).call(this);
