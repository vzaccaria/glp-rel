// Generated by LiveScript 1.2.0
(function(){
  var _, winston, path, es, debug, chalk, concat, pass, toArray, handleError, _module;
  _ = require('underscore');
  _.str = require('underscore.string');
  winston = require('winston');
  path = require('path');
  es = require('event-stream');
  path = require('path');
  debug = require('debug')('glp:gulp-relations');
  chalk = require('chalk');
  concat = require('gulp-concat');
  pass = require('stream').PassThrough;
  toArray = require('stream-to-array');
  _.mixin(_.str.exports());
  _.str.include('Underscore.string', 'string');
  handleError = function(err){
    console.log(chalk.red(err));
    console.log(chalk.red("Terminating"));
    return process.exit(1);
  };
  _module = function(gulp){
    var __, tap, buildConditionalStream, emit, manyToMany, manyToOne, iface;
    __ = {};
    tap = function(n){
      return __.observe(function(it){
        return console.log(chalk.blue("@ " + n + " "), path.basename(it.path), it.contents.length);
      });
    };
    __.filter = function(f){
      return es.map(function(data, cb){
        var rez;
        console.log(f.toString());
        rez = f(data);
        if (_.isBoolean(rez)) {
          if (rez) {
            return cb(null, data);
          } else {
            return cb();
          }
        }
      });
    };
    __.observe = function(f){
      return es.map(function(data, cb){
        var rez;
        rez = f(data);
        return cb(null, data);
      });
    };
    __.merge = function(sa, name){
      var reduction;
      name == null && (name = "");
      if (sa.length === 0) {
        throw "You must merge at least two streams";
      }
      if (sa.length === 1) {
        return sa[0];
      }
      reduction = function(a, n){
        var m;
        m = es.merge(a, n);
        m.on('error', handleError);
        return m;
      };
      return _.reduce(_.tail(sa), reduction, sa[0]);
    };
    __.pipe = function(sa, name){
      var reduction;
      name == null && (name = "");
      if (sa.length === 0) {
        throw "You must pipe at least two streams";
      }
      if (sa.length === 1) {
        return sa[0];
      }
      reduction = function(a, n){
        var p;
        p = a.pipe(n);
        p.on('error', handleError);
        return p;
      };
      return _.reduce(_.tail(sa), reduction, sa[0]);
    };
    buildConditionalStream = function(src, filters, name){
      var source, dest, merged;
      source = gulp.src(src);
      if (!filters) {
        return source;
      }
      dest = es.through();
      _.map(filters, function(f){
        f.input = es.through();
        return f.output = (function(){
          switch (false) {
          case !_.isFunction(f.plugin):
            return f.input.pipe(f.plugin());
          default:
            return f.input;
          }
        }());
      });
      merged = __.merge(filters.map(function(it){
        return it.output;
      }), name);
      toArray(source, function(err, array){
        var k, file, ff, i$, ref$, len$, filt, results$ = [];
        for (k in array) {
          file = array[k];
          ff = {
            path: file.path
          };
          for (i$ = 0, len$ = (ref$ = filters).length; i$ < len$; ++i$) {
            filt = ref$[i$];
            if (filt.pred(ff)) {
              filt.input.write(file);
            }
          }
        }
        for (i$ = 0, len$ = (ref$ = filters).length; i$ < len$; ++i$) {
          filt = ref$[i$];
          results$.push(filt.input.end());
        }
        return results$;
      });
      return merged;
    };
    emit = function(it){
      if (process.env.FILTER != null) {
        if (in$(path.extname(it.path), _.words(process.env.FILTER, /,/))) {
          return true;
        }
        return false;
      } else {
        return true;
      }
    };
    manyToMany = function(name, src, finalDir, options, isToOne){
      var filters, finalDest, complete;
      options == null && (options = {});
      filters = options.compilers;
      finalDest = "";
      if (isToOne != null && isToOne) {
        finalDest = path.basename(finalDir);
        finalDir = path.dirname(finalDir);
        if (options != null) {
          options.tempBuild == null && (options.tempBuild = finalDir + "/build");
        }
        complete = __.pipe([buildConditionalStream(src, filters, name), gulp.dest(options.tempBuild), concat(finalDest), gulp.dest(finalDir)]);
        return complete;
      } else {
        complete = __.pipe([buildConditionalStream(src, filters, name), gulp.dest(finalDir)]);
        return complete;
      }
    };
    manyToOne = function(name, src, finalDest, options){
      return manyToMany(name, src, finalDest, options, true);
    };
    iface = {
      manyToOne: manyToOne,
      manyToMany: manyToMany
    };
    return iface;
  };
  module.exports = _module;
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
